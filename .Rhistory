,  {"run_id":116,
"task_id":2,
"setup_id":4,
"flow_id":59,
"flow_name":"weka.JRip(1)",
"data_name":"anneal",
"function":"prior_entropy",
"upload_time":"2014-04-07 00:27:44"
,"value":1.214875     }
,  {"run_id":116,
"task_id":2,
"setup_id":4,
"flow_id":59,
"flow_name":"weka.JRip(1)",
"data_name":"anneal",
"function":"recall",
"upload_time":"2014-04-07 00:27:44"
,"value":0.951002   ,"array_data":[0.5,0.808081,0.972222,0,1,0.95]  }
,  {"run_id":116,
"task_id":2,
"setup_id":4,
"flow_id":59,
"flow_name":"weka.JRip(1)",
"data_name":"anneal",
"function":"relative_absolute_error",
"upload_time":"2014-04-07 00:27:44"
,"value":0.172694     }
,  {"run_id":116,
"task_id":2,
"setup_id":4,
"flow_id":59,
"flow_name":"weka.JRip(1)",
"data_name":"anneal",
"function":"root_mean_prior_squared_error",
"upload_time":"2014-04-07 00:27:44"
,"value":0.258218     }
,  {"run_id":116,
"task_id":2,
"setup_id":4,
"flow_id":59,
"flow_name":"weka.JRip(1)",
"data_name":"anneal",
"function":"root_mean_squared_error",
"upload_time":"2014-04-07 00:27:44"
,"value":0.117284     }
,  {"run_id":116,
"task_id":2,
"setup_id":4,
"flow_id":59,
"flow_name":"weka.JRip(1)",
"data_name":"anneal",
"function":"root_relative_squared_error",
"upload_time":"2014-04-07 00:27:44"
,"value":0.454206     }
,  {"run_id":116,
"task_id":2,
"setup_id":4,
"flow_id":59,
"flow_name":"weka.JRip(1)",
"data_name":"anneal",
"function":"scimark_benchmark",
"upload_time":"2014-04-07 00:27:44"
,"value":1987.68437053419   ,"array_data":[ 1240.5695344299615, 1604.4588241327313, 924.4441198095968, 1677.7215999999999,"4491.227774298661"]  }
,  {"run_id":116,
"task_id":2,
"setup_id":4,
"flow_id":59,
"flow_name":"weka.JRip(1)",
"data_name":"anneal",
"function":"total_cost",
"upload_time":"2014-04-07 00:27:44"
,"value":0     }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"area_under_roc_curve",
"upload_time":"2014-04-07 03:47:18"
,"value":0.941548   ,"array_data":[0.958919,0.930437,0.936858,0.0,0.981878,0.978234]  }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"average_cost",
"upload_time":"2014-04-07 03:47:18"
,"value":0     }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"f_measure",
"upload_time":"2014-04-07 03:47:18"
,"value":0.925136   ,"array_data":[0.857143,0.787565,0.952451,0,0.882759,0.883117]  }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"kappa",
"upload_time":"2014-04-07 03:47:18"
,"value":0.813827     }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"kb_relative_information_score",
"upload_time":"2014-04-07 03:47:18"
,"value":673.830469     }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"mean_absolute_error",
"upload_time":"2014-04-07 03:47:18"
,"value":0.038507     }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"mean_prior_absolute_error",
"upload_time":"2014-04-07 03:47:18"
,"value":0.134305     }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"number_of_instances",
"upload_time":"2014-04-07 03:47:18"
,"value":898   ,"array_data":[8,99,684,0,67,40]  }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"os_information",
"upload_time":"2014-04-07 03:47:18"
,"array_data":["Oracle Corporation","1.7.0_51","amd64","Linux","3.7.10-1.28-desktop"]  }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"precision",
"upload_time":"2014-04-07 03:47:18"
,"value":0.926199   ,"array_data":[1,0.808511,0.953148,0,0.820513,0.918919]  }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"predictive_accuracy",
"upload_time":"2014-04-07 03:47:18"
,"value":0.92539     }
,  {"run_id":321,
"task_id":2,
"setup_id":9,
"flow_id":64,
"flow_name":"weka.RandomTree(1)",
"data_name":"anneal",
"function":"prior_entropy",
"upload_time":"2014-04-07 03:47:18"
,"value":1.214875     }
]}
}'
res = fromJSON(txt = str2, simplifyVector = FALSE)
res
library(OpenML)
packrat::disable()
library(purrr)
library(tidyverse)
path <- "E:/OpenMLData/"
files <- dir(path, pattern = "*.json")
OpenMLRunEvaluations <- files %>%
map_df(~fromJSON(file.path(path, .), flatten = TRUE))
library(jsonlite)
OpenMLRunEvaluations <- files %>%
map_df(~fromJSON(file.path(path, .), flatten = TRUE))
library(plyr)
nm <- list.files(path="E:/OpenMLData/")
do.call(rbind.fill, lapply(nm, function(x) fromJSON(paste(paste(readLines(x), collapse = ""), "}"))$evaluations$evaluation))
nm
readLines(nm[1])
readLines(paste("E:/OpenMLData/", nm[1], sep = ""))
do.call(rbind.fill, lapply(nm, function(x) fromJSON(paste(paste(readLines(paste("E:/OpenMLData/", x, sep = "")), collapse = ""), "}"))$evaluations$evaluation))
do.call(rbind.fill,
lapply(nm, function(x) {
print(paste("Reading:" , x))
fromJSON(paste(
paste(readLines(paste(
"E:/OpenMLData/", x, sep = ""
)), collapse = ""), "}"
))$evaluations$evaluation
})
)
do.call(rbind.fill,
lapply(nm[1:10], function(x) {
print(paste("Reading:" , x))
fromJSON(paste(
paste(readLines(paste(
"E:/OpenMLData/", x, sep = ""
)), collapse = ""), "}"
))$evaluations$evaluation
})
)
OpenMLRunEvaluations <- do.call(rbind.fill,
lapply(nm[1:10], function(x) {
print(paste("Reading:" , x))
fromJSON(paste(
paste(readLines(paste(
"E:/OpenMLData/", x, sep = ""
)), collapse = ""), "}"
))$evaluations$evaluation
})
)
names(OpenMLRunEvaluations)
length(nm)
rm(str)
str(OpenMLRunEvaluations)
OpenMLRunEvaluations
OpenMLRunEvaluations <- do.call(rbind.fill,
lapply(nm, function(x) {
print(paste("Reading:" , x))
fromJSON(paste(
paste(readLines(paste(
"E:/OpenMLData/", x, sep = ""
)), collapse = ""), "}"
))$evaluations$evaluation
})
)
data.frame()
OpenMLRunEvaluations <- do.call(rbind.fill,
lapply(nm, function(x) {
print(paste("Reading:" , x))
run.results.set.n <- tryCatch(
fromJSON(paste(
paste(readLines(paste(
"E:/OpenMLData/", x, sep = ""
)), collapse = ""), "}"
))$evaluations$evaluation,
error = function(e)
e
)
if (inherits(run.results.set.n, "error")) {
print("!!!!!!!!!!!!!!!!!!! Bad String !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
return(data.frame())
}
})
)
OpenMLRunEvaluations <- do.call(rbind.fill,
lapply(nm, function(x) {
print(paste("Reading:" , x))
run.results.set.n <- tryCatch(
fromJSON(paste(
paste(readLines(paste(
"E:/OpenMLData/", x, sep = ""
)), collapse = ""), "}"
))$evaluations$evaluation,
error = function(e)
e
)
if (inherits(run.results.set.n, "error")) {
print("!!!!!!!!!!!!!!!!!!! Bad String !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
return(data.frame())
}
run.results.set.n
})
)
59L
library(OpenML)
run.results = listOMLRunEvaluations(task.id = 59L)
str(run.results)
names(OpenMLRunEvaluations)
re <- OpenMLRunEvaluations[OpenMLRunEvaluations$task_id=59,]
re <- OpenMLRunEvaluations[OpenMLRunEvaluations$task_id==59,]
run.results$run.id
re$run_id
OpenMLRunEvaluationsFixed <- OpenMLRunEvaluations
evals = rbindlist(lapply(OpenMLRunEvaluationsFixed, function(x) {
if (is.null(x$value))
x$value = NA
if (is.null(x$array_data))
x$array_data = NA
else
x$array_data = collapse(x$array_data)
cols = c(
"run_id",
"task_id",
"setup_id",
"flow_id",
"flow_name",
"data_name",
"upload_time",
"function",
"value",
"array_data"
)
x[cols]
}))
library(data.table)
evals = rbindlist(lapply(OpenMLRunEvaluationsFixed, function(x) {
if (is.null(x$value))
x$value = NA
if (is.null(x$array_data))
x$array_data = NA
else
x$array_data = collapse(x$array_data)
cols = c(
"run_id",
"task_id",
"setup_id",
"flow_id",
"flow_name",
"data_name",
"upload_time",
"function",
"value",
"array_data"
)
x[cols]
}))
rm(OpenMLRunEvaluationsFixed)
evals <- OpenMLRunEvaluations
# convert long format to wide format
setnames(evals, "function", "fun")
form = run_id + task_id + setup_id + flow_id + flow_name + data_name + upload_time ~ fun
evals = dcast(
data = evals,
formula = form,
value.var = c("value", "array_data")
)
form = run_id + task_id + setup_id + flow_id + flow_name + data_name + upload_time ~ function
form = run_id + task_id + setup_id + flow_id + flow_name + data_name + upload_time ~ `function`
form
# convert long format to wide format
setnames(evals, "function", "fun")
names(evals)
form = run_id + task_id + setup_id + flow_id + flow_name + data_name + upload_time ~ fun
evals = dcast(
data = evals,
formula = form,
value.var = c("value", "array_data")
)
evals <- as.data.table(OpenMLRunEvaluations)
# convert long format to wide format
setnames(evals, "function", "fun")
form = run_id + task_id + setup_id + flow_id + flow_name + data_name + upload_time ~ fun
evals = dcast(
data = evals,
formula = form,
value.var = c("value", "array_data")
)
# drop "all NA" columns
evals = as.data.frame(evals)[, vlapply(evals, function(x)
! all(is.na(x)))]
install.packages("BBmisc")
library(BBmisc)
# drop "all NA" columns
evals = as.data.frame(evals)[, vlapply(evals, function(x)
! all(is.na(x)))]
# drop "all NA" columns
evals = as.data.frame(evals)[, vlapply(evals, function(x)
! all(is.na(x)))]
# unfortunately column names are f***ed up now. Some tedious work is neccessary
# to achive our naming conventions
colnames(evals) = stri_replace_all_fixed(colnames(evals), "value_", "")
library(stringi)
# unfortunately column names are f***ed up now. Some tedious work is neccessary
# to achive our naming conventions
colnames(evals) = stri_replace_all_fixed(colnames(evals), "value_", "")
arr.ind = stri_detect_fixed(colnames(evals), "array_data_")
colnames(evals)[arr.ind] = paste0(stri_replace_all_fixed(colnames(evals)[arr.ind], "array_data_", ""),
"_array")
if (!show.array.measures) {
evals = evals[,!arr.ind]
}
# finally convert _ to . in col names
names(evals) = convertNamesOMLToR(names(evals))
convertNamesOMLToR = function(names) {
assertCharacter(names, any.missing = FALSE, all.missing = FALSE)
# a_b_c to a.b.c
new.names = stri_replace_all_fixed(names, "_", ".")
# did to data.id
new.names = gsub("^did$", "data.id", new.names)
# ServerVar to server.var
new.names = gsub("([a-z])([A-Z])", "\\1.\\L\\2", new.names, perl = TRUE)
# make first character lower case
new.names = sub("^(.[a-z])", "\\L\\1", new.names, perl = TRUE)
return(new.names)
}
# finally convert _ to . in col names
names(evals) = convertNamesOMLToR(names(evals))
library(checkmate)
# finally convert _ to . in col names
names(evals) = convertNamesOMLToR(names(evals))
names(evals)
evals$task.id
run.results
str(run.results)
str(evals[evals$task.id==2])
str(evals[evals$task.id==2],)
str(evals[evals$task.id==2,])
evals[evals$task.id==2,]$area.under.roc.curve
OpenMLRunEvaluations[OpenMLRunEvaluations$task.id==2,]$area.under.roc.curve
OpenMLRunEvaluations[OpenMLRunEvaluations$task.id==2,]
OpenMLRunEvaluations[OpenMLRunEvaluations$task_id==2,]$area.under.roc.curve
OpenMLRunEvaluations[OpenMLRunEvaluations$task_id==2,]
unique(evals$area.under.roc.curve)
unique(evals$area.under.roc.curve.array)
unique(OpenMLRunEvaluations[OpenMLRunEvaluations$fun=='area_under_roc_curve']$value)
unique(OpenMLRunEvaluations[OpenMLRunEvaluations$fun=='area_under_roc_curve',]$value)
evals <- as.data.table(OpenMLRunEvaluations)
library(data.table)
evals <- as.data.table(OpenMLRunEvaluations)
# convert long format to wide format
setnames(evals, "function", "fun")
form = run_id + task_id + setup_id + flow_id + flow_name + data_name + upload_time ~ fun
evals = dcast(
data = evals,
formula = form,
value.var = c("value", "array_data"),
fun.aggregate = mean
)
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data")
)
unique(evals$value_area_under_roc_curve)
?dcast\
?dcast
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data"),
fun.aggregate = list(sum, mean)
)
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data"),
fun.aggregate = sum
)
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data")
)
evals <- as.data.table(OpenMLRunEvaluations)
form = run_id + task_id + setup_id + flow_id + flow_name + data_name + upload_time ~ fun
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data"),
fun.aggregate = list(sum, mean)
)
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data"),
fun.aggregate = sum
)
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data"),
fun.aggregate = mean
)
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data"),
fun.aggregate = sum
)
evals = data.table::dcast(
data = evals,
formula = form,
value.var = c("value", "array_data"),
fun = sum
)
install.packages("arules")
library(arulse)
library(arules)
mining <- ruleInduction(evals)
?ruleInduction
data("Adults")
data("Adult")
write.csv(OpenMLRunEvaluations, "data/")
write.csv(OpenMLRunEvaluations, "./data/OpenMLRunEvaluations.csv")
class(OpenMLRunEvaluations)
names(OpenMLRunEvaluations)
OpenMLRunEvaluations$array_data[1:10]
write.csv(OpenMLRunEvaluations[,1:9], "./data/OpenMLRunEvaluations.csv")
rm(evals)
rm(Adult, datasets, res, run.results1, arr.ind, files, form, ids, nm, path, str2)
